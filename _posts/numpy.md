---
title: Numpy笔记
date: 2020-1-01 18:01:17
tags: 
- python
- numpy
categories:
cover: /img/numpy.png
---

## numpy 数组对象 ndarray
#### 为什么使用ndarray
*  科学计算涉及数据较多,对存储和性能都有较高要求。
*  对元素类型精细定义,有助于Numpy合理使用存储空间并优化性能。
*  对元素类型精细定义,有助于对程序规模有合理评估。
*  ndarray允许非同质元素构成数组（各元素类型不一致）,但无法发挥Numpy优势,尽量避免使用。
  
<details>
  <summary> 举个栗子 </summary>
  
```
>>> import numpy as np  
     
>>> a = np.array([range(5), range(5,10)])  
>>> a  
array([[0, 1, 2, 3, 4],  
[5, 6, 7, 8, 9]])   
   
>>> print(a)  
[[0 1 2 3 4]  
[5 6 7 8 9]]  
    
>>> a.ndim 
2 
    
>>> a.shape  
(2, 5)  
   
>>> a.size  
10  
   
>>> a.dtype  
dtype('int32')  
  
>>> a.itemsize  
4    
```

</details>  
  
  
***
#### ndarray对象常用属性  
  
| 方法           | 说明                                       |
| :------------- | :----------------------------------------- |
| array.ndim     | 秩,即轴的数量或维度数量                    |
| array.shape    | ndarray对象的尺度,对于矩阵,n行m列          |
| array.size     | ndarray对象元素个数,相当于.shape中n\*m的值 |
| array.dtype    | ndarray对象的元素类型                      |
| array.itemsize | ndarray对象中每个元素的大小,以字节为单位   |



***
#### ndarray的元素类型
 
| 数据类型   | 说明                                              |
| :--------- | :------------------------------------------------ |
| bool       | 布尔类型, True或False                             |
| intc       | 与C语言中int类型一致, 一半是int32或int64          |
| intp       | 用于索引的整数, 与C语言中ssize_t一致,int32或int64 |
| int8       | 字节长度的整数, 取值: [-128,127]                  |
| int16      | 16位长度的整数, 取值: [-32768,32767]              |
| int32      | 32位长度的整数, 取值: [-pow(2,31), pow(2,31)-1]   |
| int64      | 64位长度的整数, 取值: [-pow(2,63), pow(2,63)-1]   |
| uint8      | 8位无符号整数, 取值: [0,255]                      |
| uint16     | 16位无符号整数, 取值: [0,65535]                   |
| uint32     | 32位无符号整数, 取值: [0,pow(2,32)-1]             |
| uint64     | 64位无符号整数, 取值: [0,pow(2,64)-1]             |
| float16    | 16位半精度浮点数, 1位符号位,5位指数,10位尾数      |
| float32    | 32位半精度浮点数, 1位符号位,8位指数,23位尾数      |
| float64    | 64位半精度浮点数, 1位符号位,11位指数,52位尾数     |
| complex64  | 复数类型,实部和虚部都是32位浮点数                 |
| complex128 | 复数类型,实部和虚部都是64位浮点数                 |

***
#### ndarray创建方法

* 从Python中的列表、元祖等类型创建ndarray数组：
   * ` x = np.array(list/tuple/range(), dtype = np.float32)`
   * 当np.array()不指定dtype时,Numpy将根据数据情况关联一个dtype类型。
* 使用Numpy中的函数创建ndarray数组,如arange、ones、zeros等

| 函数                | 说明                                          |
| :------------------ | :-------------------------------------------- |
| np.arange(n)        | 类似range()函数,返回ndarray类型,元素从0-n-1   |
| np.ones(shape)      | 根据shape生成一个全1的数组,shape是元祖类型    |
| np.zeros(shape)     | 根据shape生成一个全0的数组,shape是元祖类型    |
| np.full(shape,val)  | 根据shape生成一个数组,每个元素的值都是val     |
| np.eye(n)           | 创建一个正方的n*n单位矩阵,对角线为1,其余为0   |
| np.ones_like(a)     | 根据数组a的形状生成一个全1数组                |
| np.zeros_like(a)    | 根据数组a的形状生成一个全0数组                |
| np.full_like(a,val) | 根据数组a的星创生成一个数组,每个元素值都是val |
| np.linspace()       | 根据起止数据间距地填充数据,形成数组           |
| np.concatenate()    | 将两个或多个数组合并成一个新数组              |



<details>
  <summary> 举个栗子 </summary>
  
``` python
>>> a = np.linspace(1,10,4)
>>> a
array([ 1.,  4.,  7., 10.])
  
>>> b = np.linspace(1,10,4,endpoint=False)
>>> b 
array([1.  , 3.25, 5.5 , 7.75])
   
>>> np.concatenate((a,b))
array([ 1.  ,  4.  ,  7.  , 10.  ,  1.  ,  3.25,  5.5 ,  7.75])
 
```

</details>  
  
  
***
 
#### ndarray数组的维度变化

| 方法               | 说明                                                |
| :----------------- | :-------------------------------------------------- |
| .reshape(shape)    | 不改变数组元素，返回一个shape形状的数组，原数组不变 |
| .resize(shape)     | 与.reshape()功能一致，但改变原数组                  |
| .swapaxes(ax1,ax2) | 将数组n个维度中的两个维度进行调换                   |
| .flatten()         | 将数组进行降维，返回折叠后的一位数组，原数组不变    |


<details>
  <summary> 栗子又来了 </summary>

```python
# 不需要特别指定np.int32/np.int64 Nunpy动态识别
>>> a = np.ones((2,3,4),dtype = np.int) 
>>> a
array([[[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]],
 
       [[1, 1, 1, 1],
        [1, 1, 1, 1],
        [1, 1, 1, 1]]])
 
>>> a.resize((3,8))
>>> a
array([[1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1]])
 
>>> a.flatten()     # 原数组a没有改变 只是返回了一位数组
array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
       1, 1])
 
>>> b = np.ones((2,3,4),dtype = np.int)
>>> c = b.astype(np.float)
>>> c                       # 没有改变原数组b
array([[[1., 1., 1., 1.],   # c里面的元素为float 
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]],

       [[1., 1., 1., 1.],
        [1., 1., 1., 1.],
        [1., 1., 1., 1.]]])
```

</details>  
  
  
***
#### ndarray数组向列表转换

<details>
  <summary> 使用ndarray的tolist()方法   </summary>

```python
>>> a = np.full((2,3,4), 23,dtype = np.int)
>>> a
array([[[23, 23, 23, 23],
        [23, 23, 23, 23],
        [23, 23, 23, 23]],
 
       [[23, 23, 23, 23],
        [23, 23, 23, 23],
        [23, 23, 23, 23]]])
  
>>> ls = a.tolist() 
 
>>> type(ls)
<class 'list'>
  
>>> ls
[[[23, 23, 23, 23], [23, 23, 23, 23], [23, 23, 23, 23]], [[23, 23, 23, 23], [23, 23, 23, 23], [23, 23, 23, 23]]]
```
  
</details>  

*** 
## ndarray数组的操作
#### 数组的索引和切片
* 一维数组的索引和切片：与Python的列表类似

<details>
  <summary> 举个栗子 </summary>
  
``` python
>>> a = np.array([9,8,7,6,5,4])
>>> a[2]
7
>>> a[1:5:2]
array([8, 6])

>>> a[1:4:2]
array([8, 6])
```
</details>  


* 多维数组的索引和切片: 
* 注意 索引时 用逗号分隔

<details>
  <summary> 举个栗子 </summary>

``` python
>>> a = np.arange(24).reshape((2,3,4))
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
 
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])
         
>>> a[1,2,3]
23
 
>>> a[0,1,2]
6
 
>>> a[-1,-2,-3]
17
 
>>> a[:,1,-3]   # 选取一个维度用 : 
array([ 5, 17])
 
>>> a[:,1:3,:]  # 第二维度选取第1-3行的数据 
array([[[ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
 
       [[16, 17, 18, 19],
        [20, 21, 22, 23]]])
         
>>> a[:,:,::2]    # 每个维度都可以用 x:x:x 这类格式切片 逗号分隔
array([[[ 0,  2],
        [ 4,  6],
        [ 8, 10]],
 
       [[12, 14],
        [16, 18],
        [20, 22]]])
```
 
</details>  

***
## ndarray数组的运算
#### 数组与标量之间的运算
数组与标量之间的运算作用与数组的每个元素
<details>
  <summary> 举个栗子 </summary>

``` python
>>> a = np.arange(24).reshape((2,3,4))
>>> a
array([[[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11]],
 
       [[12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23]]])

>>> a.mean()    # a的平均值
11.5
 
>>> a = a / a.mean()   
 
>>> a  
array([[[0.        , 0.08695652, 0.17391304, 0.26086957],
        [0.34782609, 0.43478261, 0.52173913, 0.60869565],
        [0.69565217, 0.7826087 , 0.86956522, 0.95652174]],

       [[1.04347826, 1.13043478, 1.2173913 , 1.30434783],
        [1.39130435, 1.47826087, 1.56521739, 1.65217391],
        [1.73913043, 1.82608696, 1.91304348, 2.        ]]])
```
  
</details>  

***
#### numpy一元函数
对ndarray中的数据执行元素级运算的函数  
注意原数组是否改变  
 
| 函数                                                                 | 说明                                               |
| :------------------------------------------------------------------- | :------------------------------------------------- |
| np.abs(x) np.fabs(x)                                                 | 计算数组各元素的绝对值                             |
| np.sqrt(x)                                                           | 计算数组各元素的平方根                             |
| np.square(x)                                                         | 计算数组各元素的平方                               |
| np.log(x) np.log10(x) np.log2(x)                                     | 计算数组各元素自然对数、10低对数、2底对数          |
| np.eeil(x) np.floor(x)                                               | 计算数组各元素ceiling值或floor值                   |
| np.rint(x)                                                           | 计算数组各元素的四舍五入值                         |
| np.modf(x)                                                           | 将数组各元素的小数和整数部分以两个独立数组形式返回 |
| np.cos(x) np.cosh(x)<br>np.sin(x) np.sinh(x)<br>np.tan(x) np.tanh(x) | 计算数组各元素的普通型和双曲型三角函数             |
| np.exp(x)                                                            | 计算数组各元素的指数值                             |
| np.sign(x)                                                           | 计算数组各元素的符号值, 1(+), 0, -1(-)             |

***
#### npmpy二元函数
注意 数据类型不同会结果转换类型

| 函数                                                   | 说明                       |
| :----------------------------------------------------- | :------------------------- |
| + - * / **                                             | 两个数组各元素进行对应运算 |
| np.maximum(x,y) np.fmax()<br>np.minimum(x,y) np.fmin() | 元素级的最大值 最小值计算  |
| np.mod(x,y)                                            | 元素级的模运算             |
| \> < >= <= == !=                                       | 算数比较，产生布尔类型数组 |

***
## CSV文件存储
CSV 只能有效存储一维和二维数组
* np.savetxt(frame, array,fmt='%.18e',)
    * frame : 文件、字符串或生产器，可以是.gz或.bz2压缩文件
    * array : 存入文件的数组
    * fmt : 写入文件的格式，例如: %d %.2f %.18e
    * delimiter : 分隔字符串，默认是任何空格
* np.loadtxt(frame, dtype=np.float,delimiter=None,unpack=False)
* unpack: 如果True，读入属性将分别写入不同变量

<details>
  <summary> 举个栗子 </summary>

``` python
>>> import numpy as np
>>> a = np.arange(100).reshape(5,20)
 
>>> np.savetxt("a.csv", a, fmt="%d", delimiter=",")

```
  
</details>  

***
## 多维数据的存取
* 写入文件  
* array.tofile(frame, sep='', format='%s')
    * frame : 文件、字符串。
    * sep : 数据分隔字符串，如果是空串，写入文件为二进制。
    * format : 写入数据的格式 
* 读入文件  
* np.fromfile(frame, dtype=float, count=-1, sep='')
    * from : 文件、字符串。
    * dtype : 读取的数据类型。
    * count : 读入元素个数，-1表示读入整个文件。
    * sep : 数据分隔字符串，如果是空串，写入为二进制文件

<details>
  <summary> 举个栗子 </summary>
 
``` python
# 读入时丢失维度信息
>>> import numpy as np
>>> a = np.arange(100).reshape(5,10,2)
>>> a.tofile('a.dat',sep=',',format='%d')
>>> c = np.fromfile('a.dat',dtype=np.int,sep=',')
>>> c
array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
       17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
       34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
       51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
       68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
       85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99])
```
</details>  

***
#### Numpy的文件存取  
np.save(fname, array)  
np.load(fname)  
* fname : 文件名, 以npy为扩展名，压缩扩展名为.npz
* array : 数组
* 函数写入时为二进制 在第一行写入数组的格式、维度等信息。
  
***
## Numpy随机数函数
Numpy的random子库

| 函数                       | 说明                                                                                                       |
| :------------------------- | :--------------------------------------------------------------------------------------------------------- |
| rand(d0,d1,...dn)          | 根据d0-dn创建随机数数组, 浮点数，[0,1),均匀分布                                                            |
| randn(d0,d1,...dn)         | 根据d0-dn创建随机数数组, 标准正态分布                                                                      |
| randint(low[,high,shape])  | 根据shape创建随整数或整数数组, 范围是[low,high]                                                            |
| seed(s)                    | 随机数种子, s是给定的种子值                                                                                |
| shuffle(a)                 | 根据数组a的第1轴进行随排列，改变数组a                                                                      |
| permutation(a)             | 根据数组a的第1轴产生一个新的乱序数组, 不改变原数组a                                                        |
| choice(a[,size,replace,p]) | 从一维数组a中以概率p抽取元素, 形成size形状的新数组<br>replace表示是否可以重用已经抽取过的元素, 默认为False |
| uniform(low,high,size)     | 产生具有均匀分布的数组,low起始值,high结束值,size形状                                                       |
| normal(loc,scale,size)     | 产生具有正态分布的数组,low起始值,high结束值,size形状                                                       |
| poisson(lam,size)          | 产生具有泊松分布的数组,low起始值,high结束值,size形状                                                       |

<details>
  <summary> 举个栗子 </summary>

``` python
>>> a = np.random.rand(3,4,5)
>>> a           # a中每一个元素都是0-1的浮点数
array([[[0.15452677, 0.25611673, 0.05996533, 0.30784688, 0.61076912],
        [0.97419945, 0.07812127, 0.72102359, 0.45809998, 0.28069965],
        [0.12610894, 0.73117787, 0.41185995, 0.18200208, 0.1278643 ],
        [0.62614096, 0.67611614, 0.19570993, 0.23621144, 0.37644739]],

       [[0.20285208, 0.27180896, 0.34547558, 0.6352247 , 0.18222024],
        [0.00388704, 0.61147218, 0.5460321 , 0.55337017, 0.8906205 ],
        [0.85353295, 0.22419908, 0.4497947 , 0.58824257, 0.61810413],
        [0.95949658, 0.66264975, 0.97781385, 0.2107439 , 0.92236653]],

       [[0.43066557, 0.16767049, 0.30620594, 0.12492713, 0.73658079],
        [0.07904855, 0.20670315, 0.27737149, 0.81358689, 0.49246908],
        [0.35980528, 0.24863938, 0.26525837, 0.94329196, 0.29929699],
        [0.73756989, 0.09329615, 0.62325811, 0.11992955, 0.73830728]]])
 
>>> sn = np.random.randn(3,4,5)
>>> sn          # sn中每一个元素都是正态分布选取出来的
array([[[-0.02838625,  0.19725212, -2.78155638, -0.20910768,
         -0.04593518],
        [ 2.54073355,  1.43916364, -0.78217134,  1.10371546,
         -0.05848329],
        [-0.760398  , -0.3234643 , -0.19071447,  0.08849098,
         -0.85069017],
        [ 2.0699686 ,  1.40936463,  0.6563804 , -0.28913246,
         -0.07916769]],
 
       [[ 0.36832057, -1.23341445, -0.52761537, -0.44418993,
          0.35394305],
        [ 1.15618384,  2.63391705, -1.44616932, -0.61483465,
          0.07563172],
        [ 0.361544  , -0.53745145,  0.1297379 , -0.86456911,
         -1.32498471],
        [ 0.59044686, -1.01906988,  1.21857283,  1.20345922,
          1.85626496]],
 
       [[-0.81428118,  0.17491108,  0.71956206, -1.56531225,
          0.26946859],
        [-0.23272868,  0.05699183, -0.53726088,  0.02311084,
          1.76322287],
        [ 0.42410569,  1.16464656, -0.72119028,  0.4869286 ,
          0.36995811],
        [-0.89525194, -0.28817483,  0.97878422, -1.76652812,
         -0.07994589]]])
 
>>> b = np.random.randint(100,200,(3,4))
>>> b           # b的每个元素都在100~200之间
array([[151, 112, 160, 100],
       [174, 105, 180, 111],
       [186, 188, 192, 157]])


>>> a = np.random.randint(100,200,(3,4))
>>> a
array([[110, 123, 155, 134],
       [175, 176, 155, 192],
       [131, 178, 109, 148]])
>>> np.random.shuffle(a)
>>> a
array([[175, 176, 155, 192],
       [110, 123, 155, 134],
       [131, 178, 109, 148]])
>>> np.random.shuffle(a)
>>> a
array([[175, 176, 155, 192],
       [131, 178, 109, 148],
       [110, 123, 155, 134]])


>>> b = np.random.randint(100,200,(8,))
>>> b
array([178, 113, 174, 128, 158, 193, 120, 156])
>>> np.random.choice(b, (3,2))
array([[156, 158],      # 某个元素可以被重复选取 概率相等的
       [193, 158],
       [158, 158]])
>>> np.random.choice(b,(3,2),replace=False)
array([[174, 156],      # 不允许选取相同的元素
       [158, 193],
       [113, 120]])
>>> np.random.choice(b,(3,2),p=b/np.sum(b))
array([[193, 158],      # 为每个元素赋值一个抽取概率
       [156, 158],
       [178, 174]])
>>> b           # b没有改变
array([178, 113, 174, 128, 158, 193, 120, 156])

```

</details>  
  
  
***
## Numpy的统计函数

| 函数                               | 说明                                                |
| :--------------------------------- | :-------------------------------------------------- |
| sum(a, axis=None)                  | 根据给定轴axis计算组a相关元素之和, axis整数或元祖   |
| mean(a, axis=None)                 | 根据给定轴axis计算组a相关元素的期望, axis整数或元祖 |
| average(a, axis=None,weights=None) | 根据给定轴axis计算组a相关元素的加权平均值           |
| std(a, axis=None)                  | 根据给定轴axis计算组a相关元素的标准差               |
| var(a, axis=None)                  | 根据给定轴axis计算组a相关元素的方差                 |

<details>
  <summary> 举个栗子 </summary>

``` python
>>> a = np.arange(15).reshape(3,5)
>>> a
array([[ 0,  1,  2,  3,  4],
       [ 5,  6,  7,  8,  9],
       [10, 11, 12, 13, 14]])
>>> np.sum(a)
105
 
>>> np.mean(a, axis=1)
array([ 2.,  7., 12.])
 
>>> np.mean(a, axis = 0)
array([5., 6., 7., 8., 9.])


```

</details>  
  
  
| 函数                       | 说明                                        |
| :------------------------- | :------------------------------------------ |
| min(a) max(a)              | 计算数组a中元素最小值、最大值               |
| argmin(a) argmax(a)        | 计算数组a中元素最小值、最大值的降一维后下标 |
| unravel_index(index,shape) | 根据shape将一维下标index转换成多维下标      |
| ptp(a)                     | 计算数组a中元素最大值与最小值的差           |
| median(a)                  | 计算数组a中元素的中位数 (中值)              |

<details>
  <summary> 举个栗子 </summary>

```
>>> b = np.arange(15,0,-1).reshape(3,5)
>>> b
array([[15, 14, 13, 12, 11],
       [10,  9,  8,  7,  6],
       [ 5,  4,  3,  2,  1]])
        
>>> np.max(b)
15
 
>>> np.argmax(b)
0

>>> np.unravel_index(np.argmax(b),b.shape)
(0, 0)

>>> np.ptp(b)
14

>>> np.median(b)
8.0
```

</details>  
  
  
***


## Numpy梯度函数
只有一个 
|      函数      |                          说明                          |
| :------------: | :----------------------------------------------------: |
| np.gradient(f) | 计算数组f中元素的梯度, 当f为多维时, 返回每个维度的梯度 |

梯度：
  * 连续值之间的变化率,  即斜率。
  * XY坐标轴连续三个X坐标对应的Y轴值: a,b,c,  其中b的梯度是： (c-a)/2

梯度有什么用？
  * 梯度反映了元素的变化率。有助于发现图像、声音边缘。

<details>
  <summary> 举个栗子 </summary>

```
>>> a = np.random.randint(0,20,(5))
>>> a
array([12, 10, 15, 19, 12])
 
>>> np.gradient(a)
array([-2. ,  1.5,  4.5, -1.5, -7. ])
 
>>> b = np.random.randint(0,20,(5))
>>> b
array([18,  2,  1,  5,  1])
 
>>> np.gradient(b)
array([-16. ,  -8.5,   1.5,   0. ,  -4. ])

>>> c = np.random.randint(0,50,(3,5))
>>> c
array([[24,  2, 12,  1,  7],
       [10, 14, 27,  1, 39],
       [42,  3, 30, 46,  5]])

>>> np.gradient(c)
[array([[-14. ,  12. ,  15. ,   0. ,  32. ],
       [  9. ,   0.5,   9. ,  22.5,  -1. ],
       [ 32. , -11. ,   3. ,  45. , -34. ]]), 
 array([[-22. ,  -6. ,  -0.5,  -2.5,   6. ],
       [  4. ,   8.5,  -6.5,   6. ,  38. ],
       [-39. ,  -6. ,  21.5, -12.5, -41. ]])]
```

</details>  
  
